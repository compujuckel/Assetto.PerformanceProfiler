@using System.Security.Cryptography
@using System.Text
@using System.Text.Json
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Assetto PerformanceMeter Results</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        body {
            font-family: sans-serif;
            font-size: 16px;
            max-width: 1600px;
            margin-left: auto;
            margin-right: auto;
        }

        table {
            width: 100%;
        }
        table.stats td.title, table.stats th.title {
            text-align: left;
        }
        table.stats td:not(.title), table.stats th:not(.title) {
            text-align: right;
            width: 80px;
        }
        
        table.stats td.change {
            font-size: 14px;
            font-style: italic;
            text-align: left;
        }
        
        table.stats td.change.increase {
            color: red;
        }
        
        table.stats td.change.decrease {
            color: green;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.1/chart.umd.min.js"
            integrity="sha512-CQBWl4fJHWbryGE+Pc7UAxWMUMNMWzWxF4SQo9CgkJIN1kx6djDQZjh3Y8SZ1d+6I+1zze6Z7kHXO7q3UyZAWw=="
            crossorigin="anonymous" referrerpolicy="no-referrer"></script>
</head>
<body>

<h1>Batch Results</h1>

<h2>Metadata</h2>

<SystemInfoTable Info="Results.SystemInfo"></SystemInfoTable>

<h2>Results</h2>

@foreach (var result in Results.Scenes)
{
    var chartId = Convert.ToHexStringLower(SHA1.HashData(Encoding.UTF8.GetBytes(result.Key)));
    var baseline = result.Value.Results.First();
    
    <h3>@result.Key</h3>

    <h4>CPU Time</h4>

    <div style="height: 200px">
        <canvas id="cpu-time-@chartId"></canvas>
    </div>

    <BatchStatisticsTable Baseline="baseline" Results="result.Value.Results" Accessor="s => s.CpuTimeStatistics"></BatchStatisticsTable>

    <h4>GPU Time</h4>

    <div style="height: 200px">
        <canvas id="gpu-time-@chartId"></canvas>
    </div>

    <BatchStatisticsTable Baseline="baseline" Results="result.Value.Results" Accessor="s => s.GpuTimeStatistics"></BatchStatisticsTable>

    <h4>Draw Calls</h4>

    <BatchStatisticsTable Baseline="baseline" Results="result.Value.Results" Accessor="s => s.DrawCallsStatistics" Precision="0"></BatchStatisticsTable>

    <h4>Triangles</h4>

    <BatchStatisticsTable Baseline="baseline" Results="result.Value.Results" Accessor="s => s.SceneTrianglesStatistics" Precision="0"></BatchStatisticsTable>

    <h4>VRAM Usage</h4>

    <BatchStatisticsTable Baseline="baseline" Results="result.Value.Results" Accessor="s => s.VramUsageStatistics" Precision="1"></BatchStatisticsTable>

}
<script>
    const results = @(ResultsJsonRaw);

    function generateLabels(count) {
        const labels = [];
        for (let i = 1; i <= count; i++) {
            labels.push(i);
        }

        return labels;
    }

    function drawChart(id, title, data) {
        const ctx = document.getElementById(id).getContext("2d");

        let maxLength = 0;
        const datasets = [];
        for (const dataRow of data) {

            if (dataRow.data.length > maxLength) {
                maxLength = dataRow.data.length
            }

            datasets.push({
                label: dataRow.name,
                data: dataRow.data
            });
        }

        console.log(datasets);

        const chart = new Chart(ctx, {
            type: "line",
            data: {
                labels: generateLabels(maxLength),
                datasets: datasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                elements: {
                    point: {
                        pointStyle: false
                    },
                    line: {
                        borderWidth: 1
                    }
                },
                scales: {
                    x: {
                        ticks: {
                            display: false,
                        },
                        grid: {
                            display: false
                        }
                    }
                }
            }
        });
    }

    async function sha1(str) {
        const encoder = new TextEncoder();
        const data = encoder.encode(str);
        const hashBuffer = await crypto.subtle.digest('SHA-1', data);
        const hashArray = Array.from(new Uint8Array(hashBuffer));
        return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    }

    async function drawCharts(data) {
        for (const [name, scene] of Object.entries(data.Scenes)) {
            const hashedName = await sha1(name);
            drawChart(`cpu-time-${hashedName}`, "CPU Time (ms)", Object.entries(scene.Results).map(([k, v]) => { return { name: v.CarModel, data: v.Result.Samples.CpuTimeMs } }));
            drawChart(`gpu-time-${hashedName}`, "GPU Time (ms)", Object.entries(scene.Results).map(([k, v]) => { return { name: v.CarModel, data: v.Result.Samples.GpuTimeMs } }));
        }
    }

    drawCharts(results);
</script>
</body>
</html>

@code
{
    
    [Parameter]
    public required BatchResults Results { get; set; }

    private MarkupString ResultsJsonRaw => new(JsonSerializer.Serialize(Results));
}